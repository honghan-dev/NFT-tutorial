"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const verifiable_1 = require("../../verifiable");
const js_iden3_core_1 = require("@iden3/js-iden3-core");
const utils_1 = require("../utils");
/**
 * Parser can parse claim data according to specification
 *
 * @export
 * @beta
 * @class Parser
 */
class Parser {
    /**
     *  ParseClaim creates core.Claim object from W3CCredential
     *
     * @param {W3CCredential} credential - Verifiable Credential
     * @param {string} credentialType  - credential type that will be used as schema hash e.g. https://url-to-ld-schema.com#AuthBJJCredential
     * @param {Uint8Array} jsonSchemaBytes - json schema bytes
     * @param {CoreClaimOptions} [opts] - options to parse core claim
     * @returns `Promise<CoreClaim>`
     */
    async parseClaim(credential, credentialType, jsonSchemaBytes, opts) {
        if (!opts) {
            opts = {
                revNonce: 0,
                version: 0,
                subjectPosition: verifiable_1.SubjectPosition.Index,
                merklizedRootPosition: verifiable_1.MerklizedRootPosition.None,
                updatable: false
            };
        }
        const subjectId = credential.credentialSubject['id'];
        const slots = this.parseSlots(credential, jsonSchemaBytes);
        const schemaHash = (0, utils_1.createSchemaHash)(new TextEncoder().encode(credentialType));
        const claim = js_iden3_core_1.Claim.newClaim(schemaHash, js_iden3_core_1.ClaimOptions.withIndexDataBytes(slots.indexA, slots.indexB), js_iden3_core_1.ClaimOptions.withValueDataBytes(slots.valueA, slots.valueB), js_iden3_core_1.ClaimOptions.withRevocationNonce(BigInt(opts.revNonce)), js_iden3_core_1.ClaimOptions.withVersion(opts.version));
        if (opts.updatable) {
            claim.setFlagUpdatable(opts.updatable);
        }
        if (credential.expirationDate) {
            claim.setExpirationDate(new Date(credential.expirationDate));
        }
        if (subjectId) {
            const did = js_iden3_core_1.DID.parse(subjectId.toString());
            switch (opts.subjectPosition) {
                case '':
                case verifiable_1.SubjectPosition.Index:
                    claim.setIndexId(did.id);
                    break;
                case verifiable_1.SubjectPosition.Value:
                    claim.setValueId(did.id);
                    break;
                default:
                    throw new Error('unknown subject position');
            }
        }
        switch (opts.merklizedRootPosition) {
            case verifiable_1.MerklizedRootPosition.Index: {
                const mk = await credential.merklize();
                claim.setIndexMerklizedRoot(mk.root().bigInt());
                break;
            }
            case verifiable_1.MerklizedRootPosition.Value: {
                const mk = await credential.merklize();
                claim.setValueMerklizedRoot(mk.root().bigInt());
                break;
            }
            case verifiable_1.MerklizedRootPosition.None:
                break;
            default:
                throw new Error('unknown merklized root position');
        }
        return claim;
    }
    /**
     * ParseSlots converts payload to claim slots using provided schema
     *
     * @param {W3CCredential} credential - Verifiable Credential
     * @param {Uint8Array} schemaBytes - JSON schema bytes
     * @returns `ParsedSlots`
     */
    parseSlots(credential, schemaBytes) {
        const schema = JSON.parse(new TextDecoder().decode(schemaBytes));
        if (schema?.$metadata?.serialization) {
            return this.assignSlots(credential.credentialSubject, schema.$metadata.serialization);
        }
        return {
            indexA: new Uint8Array(32),
            indexB: new Uint8Array(32),
            valueA: new Uint8Array(32),
            valueB: new Uint8Array(32)
        };
    }
    // assignSlots assigns index and value fields to specific slot according array order
    assignSlots(data, schema) {
        const result = {
            indexA: new Uint8Array(32),
            indexB: new Uint8Array(32),
            valueA: new Uint8Array(32),
            valueB: new Uint8Array(32)
        };
        result.indexA = (0, utils_1.fillSlot)(data, schema.indexDataSlotA);
        result.indexB = (0, utils_1.fillSlot)(data, schema.indexDataSlotB);
        result.valueA = (0, utils_1.fillSlot)(data, schema.valueDataSlotA);
        result.valueB = (0, utils_1.fillSlot)(data, schema.valueDataSlotB);
        return result;
    }
    /**
     * GetFieldSlotIndex return index of slot from 0 to 7 (each claim has by default 8 slots) for non-merklized claims
     *
     * @param {string} field - field name
     * @param {Uint8Array} schemaBytes -json schema bytes
     * @returns `number`
     */
    getFieldSlotIndex(field, schemaBytes) {
        const schema = JSON.parse(new TextDecoder().decode(schemaBytes));
        if (!schema?.$metadata?.serialization) {
            throw new Error('serialization info is not set');
        }
        switch (field) {
            case schema.$metadata?.serialization?.indexDataSlotA:
                return 2;
            case schema.$metadata?.serialization?.indexDataSlotB:
                return 3;
            case schema.$metadata?.serialization?.valueDataSlotA:
                return 6;
            case schema.$metadata?.serialization?.valueDataSlotB:
                return 7;
            default:
                throw new Error(`field ${field} not specified in serialization info`);
        }
    }
}
exports.Parser = Parser;
//# sourceMappingURL=parser.js.map