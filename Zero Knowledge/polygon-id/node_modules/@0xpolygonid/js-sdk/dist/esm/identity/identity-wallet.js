import { KmsKeyType } from '../kms';
import { Blockchain, buildDIDType, BytesHelper, Claim, ClaimOptions, DID, DidMethod, getUnixTimestamp, Id, NetworkId, SchemaHash } from '@iden3/js-iden3-core';
import { Hex, poseidon, PublicKey, Signature } from '@iden3/js-crypto';
import { hashElems, ZERO_HASH } from '@iden3/js-merkletree';
import { subjectPositionIndex } from './common';
import * as uuid from 'uuid';
import { Parser } from '../schema-processor';
import { MerkleTreeType } from '../storage/entities/mt';
import { getRandomBytes, keyPath } from '../kms/provider-helpers';
import { UniversalSchemaLoader } from '../loaders';
import { VerifiableConstants, MerklizedRootPosition, SubjectPosition, W3CCredential, Iden3SparseMerkleTreeProof, ProofType, IssuerData } from '../verifiable';
import { pushHashesToRHS } from '../credentials/revocation';
/**
 * @public
 * Wallet instance to manage the digital identity based on iden3 protocol
 * allows to: create identity/profile, sign payloads (bigint / bytes), generate keys,
 * generate Merkle tree proofs of inclusion / non-inclusion to Merkle trees, issue credentials with a BJJSignature and Iden3SparseMerkleTree Proofs,
 * revoke credentials, add credentials to Merkle trees, push states to reverse hash service
 *
 *
 * @export
 * @beta
 * @class IdentityWallet - class
 * @beta
 * @implements implements IIdentityWallet interface
 */
export class IdentityWallet {
    /**
     * Constructs a new instance of the `IdentityWallet` class
     *
     * @param {KMS} _kms - Key Management System that allows signing data with BJJ key
     * @param {IDataStorage} _storage - data storage to access credential / identity / Merkle tree data
     * @param {ICredentialWallet} _credentialWallet - credential wallet instance to quickly access credential CRUD functionality
     * @public
     */
    constructor(_kms, _storage, _credentialWallet) {
        this._kms = _kms;
        this._storage = _storage;
        this._credentialWallet = _credentialWallet;
    }
    /**
     * {@inheritDoc IIdentityWallet.createIdentity}
     */
    async createIdentity(hostUrl, opts) {
        const tmpIdentifier = uuid.v4();
        await this._storage.mt.createIdentityMerkleTrees(tmpIdentifier);
        if (!opts) {
            opts = {
                method: DidMethod.Iden3,
                blockchain: Blockchain.Polygon,
                networkId: NetworkId.Mumbai
            };
        }
        opts.seed = opts.seed ?? getRandomBytes(32);
        const keyID = await this._kms.createKeyFromSeed(KmsKeyType.BabyJubJub, opts.seed);
        const pubKey = await this._kms.publicKey(keyID);
        const schemaHash = SchemaHash.authSchemaHash;
        const authClaim = Claim.newClaim(schemaHash, ClaimOptions.withIndexDataInts(pubKey.p[0], pubKey.p[1]), ClaimOptions.withRevocationNonce(BigInt(0)));
        const revNonce = 0;
        authClaim.setRevocationNonce(BigInt(revNonce));
        await this._storage.mt.addToMerkleTree(tmpIdentifier, MerkleTreeType.Claims, authClaim.hiHv().hi, authClaim.hiHv().hv);
        const claimsTree = await this._storage.mt.getMerkleTreeByIdentifierAndType(tmpIdentifier, MerkleTreeType.Claims);
        const currentState = await hashElems([
            claimsTree.root.bigInt(),
            ZERO_HASH.bigInt(),
            ZERO_HASH.bigInt()
        ]);
        const didType = buildDIDType(opts.method, opts.blockchain, opts.networkId);
        const identifier = Id.idGenesisFromIdenState(didType, currentState.bigInt());
        const did = DID.parseFromId(identifier);
        await this._storage.mt.bindMerkleTreeToNewIdentifier(tmpIdentifier, did.toString());
        const schema = JSON.parse(VerifiableConstants.AUTH.AUTH_BJJ_CREDENTIAL_SCHEMA_JSON);
        const authData = authClaim.getExpirationDate();
        const expiration = authData ? getUnixTimestamp(authData) : 0;
        const request = {
            credentialSchema: VerifiableConstants.AUTH.AUTH_BJJ_CREDENTIAL_SCHEMA_JSON_URL,
            type: VerifiableConstants.AUTH.AUTH_BJJ_CREDENTIAL_TYPE,
            credentialSubject: {
                x: pubKey.p[0].toString(),
                y: pubKey.p[1].toString()
            },
            subjectPosition: subjectPositionIndex(authClaim.getIdPosition()),
            version: 0,
            expiration,
            revNonce: revNonce
        };
        hostUrl = hostUrl.replace(/\/$/, '');
        let credential = new W3CCredential();
        try {
            credential = this._credentialWallet.createCredential(hostUrl, did, request, schema, opts.rhsUrl);
        }
        catch (e) {
            throw new Error('Error create Iden3Credential');
        }
        const index = authClaim.hIndex();
        const { proof } = await claimsTree.generateProof(index, claimsTree.root);
        const claimsTreeHex = claimsTree.root.hex();
        const stateHex = currentState.hex();
        const mtpProof = new Iden3SparseMerkleTreeProof({
            type: ProofType.Iden3SparseMerkleTreeProof,
            mtp: proof,
            issuerData: new IssuerData({
                id: did.toString(),
                state: {
                    rootOfRoots: ZERO_HASH.hex(),
                    revocationTreeRoot: ZERO_HASH.hex(),
                    claimsTreeRoot: claimsTreeHex,
                    value: stateHex
                },
                authCoreClaim: authClaim.hex(),
                credentialStatus: credential.credentialStatus,
                mtp: proof
            }),
            coreClaim: authClaim.hex()
        });
        credential.proof = [mtpProof];
        await this._storage.identity.saveIdentity({
            identifier: did.toString(),
            state: currentState,
            published: false,
            genesis: true
        });
        await this._credentialWallet.save(credential);
        return {
            did,
            credential
        };
    }
    /** {@inheritDoc IIdentityWallet.createProfile} */
    async createProfile(did, nonce, verifier) {
        const id = did.id;
        const identityProfiles = await this._storage.identity.getProfilesByGenesisIdentifier(did.toString());
        const existingProfile = identityProfiles.find((p) => p.nonce == nonce || p.verifier == verifier);
        if (existingProfile) {
            throw new Error('profile with given nonce or verifier already exists');
        }
        const profile = Id.profileId(id, BigInt(nonce));
        const profileDID = DID.parseFromId(profile);
        await this._storage.identity.saveProfile({
            id: profileDID.toString(),
            nonce,
            genesisIdentifier: did.toString(),
            verifier
        });
        return profileDID;
    }
    /** {@inheritDoc IIdentityWallet.generateKey} */
    async generateKey(keyType) {
        const key = await this._kms.createKeyFromSeed(keyType, getRandomBytes(32));
        return key;
    }
    /** {@inheritDoc IIdentityWallet.getDIDTreeModel} */
    async getDIDTreeModel(did) {
        const claimsTree = await this._storage.mt.getMerkleTreeByIdentifierAndType(did.toString(), MerkleTreeType.Claims);
        const revocationTree = await this._storage.mt.getMerkleTreeByIdentifierAndType(did.toString(), MerkleTreeType.Revocations);
        const rootsTree = await this._storage.mt.getMerkleTreeByIdentifierAndType(did.toString(), MerkleTreeType.Roots);
        const state = await hashElems([
            claimsTree.root.bigInt(),
            revocationTree.root.bigInt(),
            rootsTree.root.bigInt()
        ]);
        return {
            state,
            claimsTree,
            revocationTree,
            rootsTree
        };
    }
    /** {@inheritDoc IIdentityWallet.generateClaimMtp} */
    async generateCredentialMtp(did, credential, treeState) {
        const coreClaim = await this.getCoreClaimFromCredential(credential);
        const treesModel = await this.getDIDTreeModel(did);
        const claimsTree = await this._storage.mt.getMerkleTreeByIdentifierAndType(did.toString(), MerkleTreeType.Claims);
        const { proof } = await claimsTree.generateProof(coreClaim.hIndex(), treeState ? treeState.claimsRoot : treesModel.claimsTree.root);
        return {
            proof,
            treeState: treeState ?? {
                state: treesModel.state,
                claimsRoot: treesModel.claimsTree.root,
                rootOfRoots: treesModel.rootsTree.root,
                revocationRoot: treesModel.revocationTree.root
            }
        };
    }
    /** {@inheritDoc IIdentityWallet.generateNonRevocationMtp} */
    async generateNonRevocationMtp(did, credential, treeState) {
        const coreClaim = await this.getCoreClaimFromCredential(credential);
        const revNonce = coreClaim.getRevocationNonce();
        const treesModel = await this.getDIDTreeModel(did);
        const revocationTree = await this._storage.mt.getMerkleTreeByIdentifierAndType(did.toString(), MerkleTreeType.Revocations);
        const { proof } = await revocationTree.generateProof(revNonce, treeState ? treeState.revocationRoot : treesModel.revocationTree.root);
        return {
            proof,
            treeState: treeState ?? {
                state: treesModel.state,
                claimsRoot: treesModel.claimsTree.root,
                rootOfRoots: treesModel.rootsTree.root,
                revocationRoot: treesModel.revocationTree.root
            }
        };
    }
    /** {@inheritDoc IIdentityWallet.sign} */
    async sign(message, credential) {
        const keyKMSId = this.getKMSIdByAuthCredential(credential);
        const payload = poseidon.hashBytes(message);
        const signature = await this._kms.sign(keyKMSId, BytesHelper.intToBytes(payload));
        return Signature.newFromCompressed(signature);
    }
    /** {@inheritDoc IIdentityWallet.signChallenge} */
    async signChallenge(challenge, credential) {
        const keyKMSId = this.getKMSIdByAuthCredential(credential);
        const signature = await this._kms.sign(keyKMSId, BytesHelper.intToBytes(challenge));
        return Signature.newFromCompressed(signature);
    }
    /** {@inheritDoc IIdentityWallet.issueCredential} */
    async issueCredential(issuerDID, req, hostUrl, opts) {
        if (!opts) {
            opts = {
                withRHS: ''
            };
        }
        hostUrl = hostUrl.replace(/\/$/, '');
        const schema = await new UniversalSchemaLoader('ipfs.io').load(req.credentialSchema);
        const jsonSchema = JSON.parse(new TextDecoder().decode(schema));
        let credential = new W3CCredential();
        let revNonce = 0;
        if (!req.revNonce) {
            req.revNonce = Math.round(Math.random() * 10000);
        }
        req.subjectPosition = req.subjectPosition ?? SubjectPosition.Index;
        revNonce = req.revNonce;
        try {
            credential = this._credentialWallet.createCredential(hostUrl, issuerDID, req, jsonSchema, opts.withRHS);
        }
        catch (e) {
            throw new Error('Error create Iden3Credential');
        }
        const issuerAuthBJJCredential = await this._credentialWallet.getAuthBJJCredential(issuerDID);
        const coreClaimOpts = {
            revNonce: revNonce,
            subjectPosition: req.subjectPosition,
            merklizedRootPosition: this.defineMTRootPosition(jsonSchema, req.merklizedRootPosition),
            updatable: false,
            version: 0
        };
        const coreClaim = await new Parser().parseClaim(credential, `${jsonSchema.$metadata.uris['jsonLdContext']}#${req.type}`, schema, coreClaimOpts);
        const { hi, hv } = coreClaim.hiHv();
        const coreClaimHash = poseidon.hash([hi, hv]);
        const keyKMSId = this.getKMSIdByAuthCredential(issuerAuthBJJCredential);
        const signature = await this._kms.sign(keyKMSId, BytesHelper.intToBytes(coreClaimHash));
        if (!issuerAuthBJJCredential.proof) {
            throw new Error('issuer auth credential must have proof');
        }
        const mtpAuthBJJProof = issuerAuthBJJCredential.proof[0];
        const sigProof = {
            type: ProofType.BJJSignature,
            issuerData: new IssuerData({
                id: issuerDID.toString(),
                state: mtpAuthBJJProof.issuerData.state,
                authCoreClaim: mtpAuthBJJProof.coreClaim,
                mtp: mtpAuthBJJProof.mtp,
                credentialStatus: mtpAuthBJJProof.issuerData.credentialStatus
            }),
            coreClaim: coreClaim.hex(),
            signature: Hex.encodeString(signature)
        };
        credential.proof = [sigProof];
        return credential;
    }
    /** {@inheritDoc IIdentityWallet.revokeCredential} */
    async revokeCredential(issuerDID, credential) {
        const issuerTree = await this.getDIDTreeModel(issuerDID);
        const coreClaim = credential.getCoreClaimFromProof(ProofType.BJJSignature);
        if (!coreClaim) {
            throw new Error('credential must have coreClaim representation in the signature proof');
        }
        const nonce = coreClaim.getRevocationNonce();
        await issuerTree.revocationTree.add(nonce, BigInt(0));
        return Number(BigInt.asUintN(64, nonce));
    }
    /** {@inheritDoc IIdentityWallet.addCredentialsToMerkleTree} */
    async addCredentialsToMerkleTree(credentials, issuerDID) {
        const oldIssuerTree = await this.getDIDTreeModel(issuerDID);
        const oldTreeState = {
            revocationRoot: oldIssuerTree.revocationTree.root,
            claimsRoot: oldIssuerTree.claimsTree.root,
            state: oldIssuerTree.state,
            rootOfRoots: oldIssuerTree.rootsTree.root
        };
        for (let index = 0; index < credentials.length; index++) {
            const credential = credentials[index];
            // credential must have a bjj signature proof
            const coreClaim = await credential.getCoreClaimFromProof(ProofType.BJJSignature);
            if (!coreClaim) {
                throw new Error('credential must have coreClaim representation in the signature proof');
            }
            await this._storage.mt.addToMerkleTree(issuerDID.toString(), MerkleTreeType.Claims, coreClaim.hIndex(), coreClaim.hValue());
        }
        const newIssuerTreeState = await this.getDIDTreeModel(issuerDID);
        await this._storage.mt.addToMerkleTree(issuerDID.toString(), MerkleTreeType.Roots, newIssuerTreeState.claimsTree.root.bigInt(), BigInt(0));
        const newIssuerTreeStateWithROR = await this.getDIDTreeModel(issuerDID);
        return {
            credentials,
            newTreeState: {
                revocationRoot: newIssuerTreeStateWithROR.revocationTree.root,
                claimsRoot: newIssuerTreeStateWithROR.claimsTree.root,
                state: newIssuerTreeStateWithROR.state,
                rootOfRoots: newIssuerTreeStateWithROR.rootsTree.root
            },
            oldTreeState: oldTreeState
        };
    }
    /** {@inheritDoc IIdentityWallet.generateIden3SparseMerkleTreeProof} */
    async generateIden3SparseMerkleTreeProof(issuerDID, credentials, txId, blockNumber, blockTimestamp) {
        for (let index = 0; index < credentials.length; index++) {
            const credential = credentials[index];
            const mtpWithProof = await this.generateCredentialMtp(issuerDID, credential);
            // credential must have a bjj signature proof
            const coreClaim = credential.getCoreClaimFromProof(ProofType.BJJSignature);
            if (!coreClaim) {
                throw new Error('credential must have coreClaim representation in the signature proof');
            }
            const mtpProof = new Iden3SparseMerkleTreeProof({
                type: ProofType.Iden3SparseMerkleTreeProof,
                mtp: mtpWithProof.proof,
                issuerData: new IssuerData({
                    id: issuerDID.toString(),
                    state: {
                        claimsTreeRoot: mtpWithProof.treeState.claimsRoot.hex(),
                        revocationTreeRoot: mtpWithProof.treeState.revocationRoot.hex(),
                        rootOfRoots: mtpWithProof.treeState.rootOfRoots.hex(),
                        value: mtpWithProof.treeState.state.hex(),
                        txId,
                        blockNumber,
                        blockTimestamp
                    },
                    mtp: mtpWithProof.proof
                }),
                coreClaim: coreClaim.hex()
            });
            if (Array.isArray(credentials[index].proof)) {
                credentials[index].proof.push(mtpProof);
            }
            else {
                credentials[index].proof = mtpProof;
            }
        }
        return credentials;
    }
    /** {@inheritDoc IIdentityWallet.publishStateToRHS} */
    async publishStateToRHS(issuerDID, rhsURL, revokedNonces) {
        const treeState = await this.getDIDTreeModel(issuerDID);
        await pushHashesToRHS(treeState.state, {
            revocationTree: treeState.revocationTree,
            claimsTree: treeState.claimsTree,
            state: treeState.state,
            rootsTree: treeState.rootsTree
        }, rhsURL, revokedNonces);
    }
    getKMSIdByAuthCredential(credential) {
        if (credential.type.indexOf('AuthBJJCredential') === -1) {
            throw new Error("can't sign with not AuthBJJCredential credential");
        }
        const x = credential.credentialSubject['x'];
        const y = credential.credentialSubject['y'];
        const pb = new PublicKey([BigInt(x), BigInt(y)]);
        const kp = keyPath(KmsKeyType.BabyJubJub, pb.hex());
        return { type: KmsKeyType.BabyJubJub, id: kp };
    }
    defineMTRootPosition(schema, position) {
        if (schema.$metadata?.serialization) {
            return '';
        }
        if (position) {
            return position;
        }
        return MerklizedRootPosition.Index;
    }
    async getCoreClaimFromCredential(credential) {
        const coreClaimFromSigProof = credential.getCoreClaimFromProof(ProofType.BJJSignature);
        const coreClaimFromMtpProof = credential.getCoreClaimFromProof(ProofType.Iden3SparseMerkleTreeProof);
        if (coreClaimFromMtpProof &&
            coreClaimFromSigProof &&
            coreClaimFromMtpProof.hex() !== coreClaimFromSigProof.hex()) {
            throw new Error('core claim representations is set in both proofs but they are not equal');
        }
        if (!coreClaimFromMtpProof && !coreClaimFromSigProof) {
            throw new Error('core claim is not set in credential proofs');
        }
        //eslint-disable-next-line  @typescript-eslint/no-non-null-assertion
        const coreClaim = coreClaimFromMtpProof ?? coreClaimFromSigProof;
        return coreClaim;
    }
}
//# sourceMappingURL=identity-wallet.js.map