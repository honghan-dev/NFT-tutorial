import { newHashFromBigInt, ZERO_HASH, setBitBigEndian, testBit, NodeLeaf } from '@iden3/js-merkletree';
import axios from 'axios';
import { NODE_TYPE_LEAF, Proof } from '@iden3/js-merkletree';
import { hashElems } from '@iden3/js-merkletree';
import { strMTHex } from '../circuits';
var NodeType;
(function (NodeType) {
    NodeType[NodeType["Unknown"] = 0] = "Unknown";
    NodeType[NodeType["Middle"] = 1] = "Middle";
    NodeType[NodeType["Leaf"] = 2] = "Leaf";
    NodeType[NodeType["State"] = 3] = "State";
})(NodeType || (NodeType = {}));
/**
 * ProofNode is a partial Reverse Hash Service result
 * it contains the current node hash and its children
 *
 * @export
 * @beta
 * @class ProofNode
 */
export class ProofNode {
    /**
     *
     * Creates an instance of ProofNode.
     * @param {Hash} [hash=ZERO_HASH] - current node hash
     * @param {Hash[]} [children=[]] -  children of the node
     */
    constructor(hash = ZERO_HASH, children = []) {
        this.hash = hash;
        this.children = children;
    }
    /**
     * Determination of Node type
     * Can be: Leaf, Middle or State node
     *
     * @returns NodeType
     */
    nodeType() {
        if (this.children.length === 2) {
            return NodeType.Middle;
        }
        if (this.children.length === 3 &&
            this.children[2].hex() === newHashFromBigInt(BigInt(1)).hex()) {
            return NodeType.Leaf;
        }
        if (this.children.length === 3) {
            return NodeType.State;
        }
        return NodeType.Unknown;
    }
    /**
     * JSON Representation of ProofNode with a hex values
     *
     * @returns {*} - ProofNode with hexes
     */
    toJSON() {
        return {
            hash: this.hash.hex(),
            children: this.children.map((h) => h.hex())
        };
    }
    /**
     * Creates ProofNode Hashes from hex values
     *
     * @static
     * @param {ProofNodeHex} hexNode
     * @returns ProofNode
     */
    static fromHex(hexNode) {
        return new ProofNode(strMTHex(hexNode.hash), hexNode.children.map((ch) => strMTHex(ch)));
    }
}
/**
 *
 * Fetches and Builds a revocation status for a given credential
 * Supported types for credentialStatus field: SparseMerkleTreeProof, Iden3ReverseSparseMerkleTreeProof
 *
 * @export
 * @param {DID} issuer - issuer identity
 * @param {(CredentialStatus | RHSCredentialStatus)} credStatus - credentialStatus field from the W3C verifiable credential
 * @param {IStateStorage} stateStorage - storage to fetch current issuer status
 * @returns Promise<RevocationStatus>
 */
export async function getStatusFromRHS(issuer, credStatus, stateStorage) {
    const latestStateInfo = await stateStorage.getLatestStateById(issuer.id.bigInt());
    const hashedRevNonce = newHashFromBigInt(BigInt(credStatus.revocationNonce ?? 0));
    const hashedIssuerRoot = newHashFromBigInt(BigInt(latestStateInfo?.state ?? 0));
    return getRevocationStatusFromRHS(hashedRevNonce, hashedIssuerRoot, credStatus.id);
}
/**
 * Gets partial revocation status info from rhs service.
 *
 * @param {Hash} data - hash to fetch
 * @param {Hash} issuerRoot - issuer root which is a part of url
 * @param {string} rhsURL - base URL for reverse hash service
 * @returns Promise<RevocationStatus>
 */
async function getRevocationStatusFromRHS(data, issuerRoot, rhsURL) {
    if (!rhsURL)
        throw new Error('HTTP reverse hash service URL is not specified');
    const treeRoots = (await axios.get(`${rhsURL}/node/${issuerRoot.hex()}`)).data
        ?.node;
    if (treeRoots.children.length !== 3) {
        throw new Error('state should has tree children');
    }
    const s = issuerRoot.hex();
    const cTR = treeRoots.children[0];
    const rTR = treeRoots.children[1];
    const roTR = treeRoots.children[2];
    const rtrHashed = strMTHex(rTR);
    const nonRevProof = await rhsGenerateProof(rtrHashed, data, `${rhsURL}/node`);
    return {
        mtp: nonRevProof,
        issuer: {
            state: s,
            claimsTreeRoot: cTR,
            revocationTreeRoot: rTR,
            rootOfRoots: roTR
        }
    };
}
async function newProofFromData(existence, allSiblings, nodeAux) {
    const p = new Proof();
    p.existence = existence;
    p.nodeAux = nodeAux;
    p.depth = allSiblings.length;
    for (let i = 0; i < allSiblings.length; i++) {
        const sibling = allSiblings[i];
        if (JSON.stringify(allSiblings[i]) !== JSON.stringify(ZERO_HASH)) {
            setBitBigEndian(p.notEmpties, i);
            p.siblings.push(sibling);
        }
    }
    return p;
}
async function rhsGenerateProof(treeRoot, key, rhsURL) {
    let exists = false;
    const siblings = [];
    let nodeAux;
    const mkProof = () => newProofFromData(exists, siblings, nodeAux);
    let nextKey = treeRoot;
    for (let depth = 0; depth < key.bytes.length * 8; depth++) {
        if (nextKey.bytes.every((i) => i === 0)) {
            return mkProof();
        }
        const resp = (await axios.get(`${rhsURL}/${nextKey.hex()}`)).data?.node;
        const n = ProofNode.fromHex(resp);
        switch (n.nodeType()) {
            case NodeType.Leaf:
                if (key.bytes.every((b, index) => b === n.children[0].bytes[index])) {
                    exists = true;
                    return mkProof();
                }
                // We found a leaf whose entry didn't match hIndex
                nodeAux = {
                    key: n.children[0],
                    value: n.children[1]
                };
                return mkProof();
            case NodeType.Middle:
                if (testBit(key.bytes, depth)) {
                    nextKey = n.children[1];
                    siblings.push(n.children[0]);
                }
                else {
                    nextKey = n.children[0];
                    siblings.push(n.children[1]);
                }
                break;
            default:
                throw new Error(`found unexpected node type in tree ${n.hash.hex()}`);
        }
    }
    throw new Error('tree depth is too high');
}
/**
 * Pushes identity state information to a reverse hash service.
 *
 * A reverse hash service (RHS) is a centralized or decentralized service for storing publicly available data about identity.
 * Such data are identity state and state of revocation tree and roots tree root tree.
 *
 * @export
 * @param {Hash} state - current state of identity
 * @param {TreesModel} trees - current trees of identity (claims, revocation, rootOfRoots )
 * @param {string} rhsUrl - URL of service
 * @param {number[]} [revokedNonces] - revoked nonces since last published info
 * @returns void
 */
export async function pushHashesToRHS(state, trees, rhsUrl, revokedNonces) {
    const nb = new NodesBuilder();
    if (revokedNonces) {
        await addRevocationNode(nb, trees, revokedNonces);
    }
    await addRoRNode(nb, trees);
    // add new state node
    if (!state.bytes.every((b) => b === 0)) {
        nb.addProofNode(new ProofNode(state, [trees.claimsTree.root, trees.revocationTree.root, trees.rootsTree.root]));
    }
    if (nb.nodes.length > 0) {
        await saveNodes(nb.nodes, rhsUrl);
    }
}
async function saveNodes(nodes, nodeUrl) {
    const nodesJSON = nodes.map((n) => n.toJSON());
    return (await (await axios.post(nodeUrl + '/node', nodesJSON)).status) === 200;
}
async function addRoRNode(nb, trees) {
    const currentRootsTree = trees.rootsTree;
    const claimsTree = trees.claimsTree;
    return nb.addKey(currentRootsTree, claimsTree.root.bigInt());
}
async function addRevocationNode(nb, trees, revokedNonces) {
    const revocationTree = trees.revocationTree;
    for (const nonce of revokedNonces) {
        await nb.addKey(revocationTree, BigInt(nonce));
    }
}
/**
 * Builder to send state information to Reverse hash Service
 *
 * @beta
 * @class NodesBuilder
 */
class NodesBuilder {
    constructor(nodes = [], seen = new Map()) {
        this.nodes = nodes;
        this.seen = seen;
    }
    async addKey(tree, nodeKey) {
        const { value: nodeValue, siblings } = await tree.get(nodeKey);
        const nodeKeyHash = newHashFromBigInt(nodeKey);
        const nodeValueHash = newHashFromBigInt(nodeValue);
        const node = new NodeLeaf(nodeKeyHash, nodeValueHash);
        const newNodes = await buildNodesUp(siblings, node);
        for (const n of newNodes) {
            if (!this.seen.get(n.hash.hex())) {
                this.nodes.push(n);
                this.seen.set(n.hash.hex(), true);
            }
        }
    }
    addProofNode(node) {
        const hex = node.hash.hex();
        const isSeen = this.seen.get(hex);
        if (!isSeen) {
            this.nodes.push(node);
            this.seen.set(hex, true);
        }
    }
}
async function buildNodesUp(siblings, node) {
    if (node.type !== NODE_TYPE_LEAF) {
        throw new Error('node is not a leaf');
    }
    let prevHash = await node.getKey();
    const sl = siblings.length;
    const nodes = new Array(sl + 1);
    for (let index = 0; index < nodes.length; index++) {
        nodes[index] = new ProofNode();
    }
    nodes[sl].hash = prevHash;
    const hashOfOne = newHashFromBigInt(BigInt(1));
    nodes[sl].children = [node.entry[0], node.entry[1], hashOfOne];
    const pathKey = node.entry[0];
    for (let i = sl - 1; i >= 0; i--) {
        const isRight = testBit(pathKey.bytes, i);
        nodes[i].children = new Array(2);
        if (isRight) {
            nodes[i].children[0] = siblings[i];
            nodes[i].children[1] = prevHash;
        }
        else {
            nodes[i].children[0] = prevHash;
            nodes[i].children[1] = siblings[i];
        }
        nodes[i].hash = await hashElems([nodes[i].children[0].bigInt(), nodes[i].children[1].bigInt()]);
        prevHash = nodes[i].hash;
    }
    return nodes;
}
/**
 *  Proof dto as a partial result of fetching credential status with type SparseMerkleTreeProof
 *
 * @export
 * @class ProofDTO
 */
export class ProofDTO {
}
/**
 * RevocationStatusDTO is a result of fetching credential status with type SparseMerkleTreeProof
 *
 * @beta
 * @export
 * @class RevocationStatusDTO
 */
export class RevocationStatusDTO {
    toRevocationStatus() {
        const p = new Proof();
        p.existence = this.mtp.existence;
        p.nodeAux = this.mtp.node_aux
            ? {
                key: newHashFromBigInt(BigInt(this.mtp.node_aux.key)),
                value: newHashFromBigInt(BigInt(this.mtp.node_aux.value))
            }
            : undefined;
        const s = this.mtp.siblings.map((s) => newHashFromBigInt(BigInt(s)));
        p.siblings = [];
        p.depth = s.length;
        for (let lvl = 0; lvl < s.length; lvl++) {
            if (s[lvl].bigInt() !== BigInt(0)) {
                setBitBigEndian(p.notEmpties, lvl);
                p.siblings.push(s[lvl]);
            }
        }
        return {
            mtp: p,
            issuer: this.issuer
        };
    }
}
//# sourceMappingURL=revocation.js.map